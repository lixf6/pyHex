# HEX地址到物理值解析流程图

## 主流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                    输入参数                                      │
│  - hex_path: HEX文件路径                                        │
│  - ecu_address: ECU地址 (字符串或整数)                          │
│  - data_type: 数据类型 (默认: FLOAT32)                          │
│  - byte_order: 字节序 (默认: little)                            │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│              步骤1: 地址解析和规范化                            │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ if isinstance(ecu_address, str):                        │  │
│  │     if ecu_address.startswith("0x"):                    │  │
│  │         address_int = int(ecu_address, 16)              │  │
│  │     else:                                                │  │
│  │         address_int = int(ecu_address)                  │  │
│  │ else:                                                    │  │
│  │     address_int = int(ecu_address)                      │  │
│  │                                                          │  │
│  │ if address_int < 0:                                     │  │
│  │     unsigned_address = address_int & 0xFFFFFFFFFFFFFFFF │  │
│  │ else:                                                   │  │
│  │     unsigned_address = address_int                      │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│              步骤2: 数据类型和字节序确定                        │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ type_map = {                                             │  │
│  │     "FLOAT32": ("<f", 4),                               │  │
│  │     "FLOAT64": ("<d", 8),                               │  │
│  │     "ULONG":   ("<I", 4),                               │  │
│  │     ...                                                  │  │
│  │ }                                                        │  │
│  │                                                          │  │
│  │ struct_format, byte_size = type_map[data_type.upper()] │  │
│  │                                                          │  │
│  │ if byte_order == "big":                                 │  │
│  │     struct_format = struct_format.replace("<", ">")     │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│              步骤3: HEX文件解析和加载                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ IntelHexFile(hex_path)                                   │  │
│  │                                                          │  │
│  │ _load() 方法:                                            │  │
│  │   1. 逐行读取HEX文件                                     │  │
│  │   2. 解析每行记录:                                       │  │
│  │      - 字节数 (byte_count)                               │  │
│  │      - 偏移地址 (offset_addr)                            │  │
│  │      - 记录类型 (record_type)                            │  │
│  │      - 数据 (data_bytes)                                 │  │
│  │   3. 处理扩展地址记录 (0x04):                            │  │
│  │      current_upper = 高16位地址                          │  │
│  │   4. 处理数据记录 (0x00):                                │  │
│  │      base_address = (current_upper << 16) + offset_addr │  │
│  │   5. 创建HexRecord对象并添加到列表                       │  │
│  │   6. 按地址排序所有记录                                  │  │
│  │   7. 构建地址索引列表 (_record_starts)                   │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│              步骤4: 从HEX文件读取指定地址的字节                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ fetch_bytes(unsigned_address, byte_size)                 │  │
│  │                                                          │  │
│  │ 1. 二分查找定位记录:                                     │  │
│  │    idx = bisect_right(_record_starts, address) - 1      │  │
│  │                                                          │  │
│  │ 2. 循环读取字节 (支持跨记录):                            │  │
│  │    while remaining > 0:                                 │  │
│  │        record = _records[idx]                           │  │
│  │        if cursor < record.base_address:                 │  │
│  │            break  # 地址不在范围内                       │  │
│  │        if cursor >= record.end_address:                 │  │
│  │            idx += 1  # 移到下一个记录                   │  │
│  │            continue                                      │  │
│  │                                                          │  │
│  │        offset = cursor - record.base_address            │  │
│  │        take = min(remaining, record.byte_count - offset)│  │
│  │        chunks.append(record.data[offset:offset+take])  │  │
│  │        cursor += take                                   │  │
│  │        remaining -= take                                │  │
│  │                                                          │  │
│  │ 3. 返回拼接的字节数据                                    │  │
│  │    return b"".join(chunks), first_line                  │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│              步骤5: 字节数据解析为物理值                         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ value = struct.unpack(struct_format, raw_bytes)[0]        │  │
│  │                                                          │  │
│  │ 根据struct_format解析:                                   │  │
│  │   - "<f": 小端序FLOAT32 → float                          │  │
│  │   - ">f": 大端序FLOAT32 → float                          │  │
│  │   - "<I": 小端序ULONG → int                              │  │
│  │   - "<i": 小端序SLONG → int                              │  │
│  │   - ...                                                  │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                    输出结果                                      │
│  - value: 解析后的物理值 (float 或 int)                         │
│  - 调试信息: 地址、行号、字节数据等                             │
└─────────────────────────────────────────────────────────────────┘
```

## HEX文件解析详细流程

```
HEX文件行示例: :10000000B8440A42B8440A42B8440A42B8440A42A8

┌─────────────────────────────────────────────────────────────┐
│ 解析HEX记录格式                                               │
├─────────────────────────────────────────────────────────────┤
│ :  [10]  [0000]  [00]  [B8440A42B8440A42...]  [A8]         │
│ │   │      │      │            │                │           │
│ │   │      │      │            │                └─ 校验和   │
│ │   │      │      │            └─ 数据 (16字节)             │
│ │   │      │      └─ 记录类型 (00=数据, 04=扩展地址)        │
│ │   │      └─ 偏移地址 (16位)                                │
│ │   └─ 数据字节数 (16字节)                                   │
│ └─ 记录起始符                                                │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│ 处理不同类型的记录                                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  记录类型 0x04 (扩展线性地址):                              │
│    ┌──────────────────────────────────────────────┐        │
│    │ current_upper = int.from_bytes(data, "big") │        │
│    │ 例如: data=[0x00, 0x04] → current_upper=4   │        │
│    │ 表示后续数据的高16位地址为 0x0004            │        │
│    └──────────────────────────────────────────────┘        │
│                                                             │
│  记录类型 0x00 (数据记录):                                  │
│    ┌──────────────────────────────────────────────┐        │
│    │ base_address = (current_upper << 16) + offset│        │
│    │ 例如: current_upper=4, offset=0x0000        │        │
│    │      base_address = (4 << 16) + 0 = 0x40000 │        │
│    │                                              │        │
│    │ 创建HexRecord对象:                          │        │
│    │   - line_no: 行号                           │        │
│    │   - byte_count: 数据字节数                  │        │
│    │   - base_address: 完整地址                  │        │
│    │   - data: 字节数据                          │        │
│    └──────────────────────────────────────────────┘        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│ 构建地址索引                                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 所有记录按base_address排序:                            │
│     records = [                                             │
│       HexRecord(base=0x40000, ...),                        │
│       HexRecord(base=0x40100, ...),                        │
│       HexRecord(base=0x40300, ...),                        │
│       ...                                                   │
│     ]                                                       │
│                                                             │
│  2. 提取地址列表用于二分查找:                               │
│     _record_starts = [0x40000, 0x40100, 0x40300, ...]     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 字节读取详细流程

```
目标: 读取地址 0x40314 的 4 字节数据

┌─────────────────────────────────────────────────────────────┐
│ 步骤1: 二分查找定位记录                                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  _record_starts = [0x40000, 0x40100, 0x40300, 0x40400]    │
│                                                             │
│  bisect_right([0x40000, 0x40100, 0x40300, 0x40400],       │
│               0x40314) = 3                                  │
│                                                             │
│  idx = 3 - 1 = 2  (找到索引2的记录)                        │
│  record = _records[2]  (base_address=0x40300)              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│ 步骤2: 计算偏移和读取字节数                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  offset = 0x40314 - 0x40300 = 0x14 = 20                    │
│  take = min(4, 256 - 20) = 4                               │
│                                                             │
│  record.data[20:24] = [0xB8, 0x44, 0x0A, 0x42]            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│ 步骤3: 返回字节数据                                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  raw_bytes = b'\xB8\x44\x0A\x42'                           │
│  first_line = record.line_no                                │
│                                                             │
│  return (raw_bytes, first_line)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 物理值解析详细流程

```
输入: raw_bytes = b'\xB8\x44\x0A\x42', struct_format = "<f"

┌─────────────────────────────────────────────────────────────┐
│ 小端序字节解释                                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  原始字节: [0xB8, 0x44, 0x0A, 0x42]                        │
│                                                             │
│  小端序解释 (低字节在前):                                    │
│    字节顺序: 0x42 0x0A 0x44 0xB8                           │
│    组合为: 0x420A44B8                                       │
│                                                             │
│  大端序解释 (高字节在前):                                    │
│    字节顺序: 0xB8 0x44 0x0A 0x42                            │
│    组合为: 0xB8440A42                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│ struct.unpack() 解析                                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  struct.unpack("<f", b'\xB8\x44\x0A\x42')                  │
│                                                             │
│  1. 按小端序读取4字节                                        │
│  2. 解释为IEEE 754单精度浮点数                              │
│  3. 返回解析后的浮点值                                       │
│                                                             │
│  结果: (32.067, )  # 元组形式                               │
│  提取: value = result[0] = 32.067                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 数据类型解析对照表

```
┌──────────┬──────────┬──────────┬──────────────────────────────┐
│ 数据类型 │ 格式字符串│ 字节数  │ 说明                         │
├──────────┼──────────┼──────────┼──────────────────────────────┤
│ FLOAT32  │ <f       │ 4        │ 小端序32位浮点数             │
│ FLOAT32  │ >f       │ 4        │ 大端序32位浮点数             │
│ FLOAT64  │ <d       │ 8        │ 小端序64位浮点数             │
│ ULONG    │ <I       │ 4        │ 小端序无符号32位整数         │
│ SLONG    │ <i       │ 4        │ 小端序有符号32位整数         │
│ UWORD    │ <H       │ 2        │ 小端序无符号16位整数         │
│ SWORD    │ <h       │ 2        │ 小端序有符号16位整数         │
│ UBYTE    │ <B       │ 1        │ 无符号8位整数                │
│ SBYTE    │ <b       │ 1        │ 有符号8位整数                │
└──────────┴──────────┴──────────┴──────────────────────────────┘

示例字节: [0xB8, 0x44, 0x0A, 0x42]

┌──────────┬──────────────────────────────────────────────────┐
│ 数据类型 │ 解析结果                                         │
├──────────┼──────────────────────────────────────────────────┤
│ FLOAT32  │ 32.067 (小端序: 0x420A44B8)                     │
│ FLOAT32  │ -5.79e-38 (大端序: 0xB8440A42)                  │
│ ULONG    │ 1107293880 (小端序: 0x420A44B8)                 │
│ SLONG    │ 1107293880 (小端序: 0x420A44B8)                 │
│ UWORD    │ 17528 (前2字节: 0x44B8)                         │
│ SWORD    │ -17528 (前2字节: 0x44B8，有符号)                │
│ UBYTE    │ 184 (第1字节: 0xB8)                             │
│ SBYTE    │ -72 (第1字节: 0xB8，有符号)                     │
└──────────┴──────────────────────────────────────────────────┘
```

## 错误处理流程

```
┌─────────────────────────────────────────────────────────────┐
│ 错误类型和处理                                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 文件不存在:                                             │
│     FileNotFoundError → 提示文件路径错误                    │
│                                                             │
│  2. 地址不在范围内:                                         │
│     KeyError → 提示地址不在HEX数据连续范围内                │
│                                                             │
│  3. 不支持的数据类型:                                       │
│     ValueError → 提示支持的数据类型列表                    │
│                                                             │
│  4. HEX文件格式错误:                                        │
│     HexParseError → 提示具体行号和错误信息                  │
│                                                             │
│  5. 负数地址处理:                                           │
│     自动转换为无符号64位地址用于查找                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

